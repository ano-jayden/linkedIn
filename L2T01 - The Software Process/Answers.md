Answers

The Incremental Development model would be the best choice. This is due to the rapid feedback this model provides. The more versions that are given to the customer, the better the feedback we, as engineers, will receive to create the best anti-locking system for cars. This is because all the feedback reports we receive help us make each version of the anti-locking system better.

The Waterfall model would be the best choice. This is because, in this model, maintenance is the longest and most important phase. This phase focuses on correcting errors that were not detected in previous stages and emphasizes enhancing and improving the systems in place. This model would be perfect for a product that emphasizes maintenance.

The Reuse-oriented software engineering model would fit this scenario. This model excels at using existing code and modifying it to fit the current requirements for a project. In this case, we would take the already established accounting system that the university uses and make modifications to it in order to replace it.

The Incremental Development model would be ideal. This is because such a system would need to go through extensive feedback reports to add every little detail the user might want to ensure it has the lowest environmental impact. Through the many feedback reports, the software engineers will have more ideas to add to the system that they may not have accounted for initially.

I believe that Incremental Development is the most effective because it is a more cost-effective way to implement changes that the customer wants, rather than going back to previous steps in the process or looking for other software that we could reuse to fit the customer’s requirements. It’s a better method of getting feedback from the customer on the work that has been produced, and this feedback improves each version.

It is important because the first step is used to define what the product will do, and the second step is used to modify the initial requirements to ensure they fit with the reused/available components. It is crucial to separate these steps so that we first define what needs to be in the product, then modify the initial requirements so that the reused software can complete the necessary task
